<<<<<<< HEAD
#include <bits/stdc++.h>

using namespace std;

/*
1 번부터 N번까지의 라면공장이 있다. i 번째 공장에서 Ai 개의 라면을 산다.

연속적으로 3개가 있을 때 9 - 2 = 7 원
연속적으로 2개가 있을 때 6 - 1 = 5 원
연속적으로 1개가 있을 때 3 - 0 = 3 원

1 5 10 10

2 4 5

10 1원

근데살수있으면무조건사는게이득아니낙 아니네

1 1 2 1 1   1 1 2 1 이런 반례 ...

2 3 2 1 이런 반례도 있다. 

1 2 1 1 7
0 1 0 1 7  ->  20
0 0 0 0 6

1 2 1 1 7
0 1 1 1 5 -> 19
0 0 0 0 7

이 반례가 어떻게 나왔는가?

2 3 2 3 3 2 1

3이랑 2를 정한 다음에, 남은 1인 찌꺼기를 처리하는 형태. 그럼 3이랑 2를 최소로 사용하는
방법을 찾아야 한다. 3이랑 2를 최소로 사용하는 형태를 어떻게 찾는가?

3 을 n 번 사용, 2 를 m 번 사용이라고 했을 때 3*(-2) + 2(-1) 번 으로 계산해서 제일많이깐거를..

6개가 있을 때, -4
              -3개
              
2 3 2 1

3번째가 더 클 때 ?? 가 문제인거임?

일단 첫번재 두번재 세번재의 관계에 대해 알아봅시다.
어차피 내림차순이면 할 수 있는게 정해짐.
그냥 2를 먹이면서, 오름차순 만들어버리기.

부분 문제로 만들어서 최적의 답임을 증명하기.

3개씩 부분을 나눠서 보는게 아닌, 3개씩 보는 것을 하나씩 옮겨가면서 완전히 보기 때문에 3개만 봐도 될것이다.
*/

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    int n; cin >> n;

    vector<int> f(n+1);
    for(int i = 0; i < n; i++) cin >> f[i];

    long long result = 0;
    for(int i = 0; i < n-2; i++) {
        
        if(f[i+1] > f[i+2]) {
            int ct = min(f[i+1] - f[i+2],f[i]);
            result += ct*5;
            f[i] -= ct;
            f[i+1] -= ct;
        }
        
        int lm = min(min(f[i],f[i+1]),f[i+2]);

        result += lm * 7;
        f[i] -= lm;
        f[i+1] -= lm;
        f[i+2] -= lm;
    }

    for(int i = 0; i < n-1; i++) {
        int lm = min(f[i],f[i+1]);

        result += lm * 5;
        f[i] -= lm;
        f[i+1] -= lm;
    }

    for(int i = 0; i < n; i++) {
        result += f[i]*3;
    }

    cout << result;

    return 0;
=======
#include <bits/stdc++.h>

using namespace std;

/*
1 번부터 N번까지의 라면공장이 있다. i 번째 공장에서 Ai 개의 라면을 산다.

연속적으로 3개가 있을 때 9 - 2 = 7 원
연속적으로 2개가 있을 때 6 - 1 = 5 원
연속적으로 1개가 있을 때 3 - 0 = 3 원

1 5 10 10

2 4 5

10 1원

근데살수있으면무조건사는게이득아니낙 아니네

1 1 2 1 1   1 1 2 1 이런 반례 ...

2 3 2 1 이런 반례도 있다. 

1 2 1 1 7
0 1 0 1 7  ->  20
0 0 0 0 6

1 2 1 1 7
0 1 1 1 5 -> 19
0 0 0 0 7

이 반례가 어떻게 나왔는가?

2 3 2 3 3 2 1

3이랑 2를 정한 다음에, 남은 1인 찌꺼기를 처리하는 형태. 그럼 3이랑 2를 최소로 사용하는
방법을 찾아야 한다. 3이랑 2를 최소로 사용하는 형태를 어떻게 찾는가?

3 을 n 번 사용, 2 를 m 번 사용이라고 했을 때 3*(-2) + 2(-1) 번 으로 계산해서 제일많이깐거를..

6개가 있을 때, -4
              -3개
              
2 3 2 1

3번째가 더 클 때 ?? 가 문제인거임?

일단 첫번재 두번재 세번재의 관계에 대해 알아봅시다.
어차피 내림차순이면 할 수 있는게 정해짐.
그냥 2를 먹이면서, 오름차순 만들어버리기.

부분 문제로 만들어서 최적의 답임을 증명하기.

3개씩 부분을 나눠서 보는게 아닌, 3개씩 보는 것을 하나씩 옮겨가면서 완전히 보기 때문에 3개만 봐도 될것이다.
*/

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    int n; cin >> n;

    vector<int> f(n+1);
    for(int i = 0; i < n; i++) cin >> f[i];

    long long result = 0;
    for(int i = 0; i < n-2; i++) {
        
        if(f[i+1] > f[i+2]) {
            int ct = min(f[i+1] - f[i+2],f[i]);
            result += ct*5;
            f[i] -= ct;
            f[i+1] -= ct;
        }
        
        int lm = min(min(f[i],f[i+1]),f[i+2]);

        result += lm * 7;
        f[i] -= lm;
        f[i+1] -= lm;
        f[i+2] -= lm;
    }

    for(int i = 0; i < n-1; i++) {
        int lm = min(f[i],f[i+1]);

        result += lm * 5;
        f[i] -= lm;
        f[i+1] -= lm;
    }

    for(int i = 0; i < n; i++) {
        result += f[i]*3;
    }

    cout << result;

    return 0;
>>>>>>> 83927147140e6241eb3207801e1b45ba28dcc889
}